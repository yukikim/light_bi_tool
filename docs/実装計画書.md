# かんたんBIツール 実装計画書

- プロジェクト名: かんたんBIツール（LightBI）
- バージョン: v0.1（MVP）
- 作成日: 2026-02-04
- 参照: [要件定義書.md](要件定義書.md), [基本設計書.md](基本設計書.md)

---

## 1. 実装方針の整理

- スコープ: 要件定義書のMVP範囲（SQL実行/保存、Dashboard & Widget、CSVアップロード「1機能」、簡易認証）に限定する。
- 優先順位:
  1. 安全なSQL実行基盤（Backend `execute` モジュール + DB read-only 設計）
  2. クエリ/ダッシュボード/ウィジェットCRUDと表示
  3. CSVアップロード〜自動テーブル作成〜サンプルSQL登録
  4. 認証とデモ用シードデータ/初期Dashboard
- 技術スタック: 基本設計書に準拠（NestJS + PostgreSQL + React/Next.js + TypeScript）。
- ポイント: 「SQLファースト」「CSV一発体験」「安全設計」を最優先とし、UIの凝った部分や高度な権限管理は後回し。

---

## 2. 全体スケジュール（ラフ）

- Phase 0: 環境構築・ベースプロジェクトのセットアップ（0.5〜1日）
- Phase 1: Backend基盤 & 認証・ユーザー管理（1〜1.5日）
- Phase 2: クエリ管理 & 安全なSQL実行モジュール（1.5〜2日）
- Phase 3: ダッシュボード/ウィジェット & フロントのチャート表示（2日）
- Phase 4: CSVアップロード〜自動テーブル作成〜サンプルSQL登録（1.5〜2日）
- Phase 5: デモ用シード/初期Dashboard、エラー・ログ整備、README/デモ準備（1〜1.5日）

※ 個人開発前提の目安。実際には並行作業や前倒しもありうる。

---

## 3. フェーズ別タスク詳細

### Phase 0: 環境構築・ベースプロジェクト

- Backend
  - NestJSプロジェクト雛形作成（`nest new backend` 相当、またはテンプレ参照）。
  - 環境変数のスキーマ定義（`DATABASE_URL`, `JWT_SECRET`, `EXECUTE_TIMEOUT_MS`, `MAX_RESULT_ROWS` 等）。
  - DB接続設定（Prisma or `pg`）、migration用の最低限設定。
- DB
  - ローカルPostgreSQL起動（Docker Composeなど）。
  - read-onlyユーザーと通常ユーザーを作成（MVPでは同一でも可だが、将来の分離を意識）。
- Frontend
  - Next.js/React + TypeScript のベース構成を確認（既存[app](../app)配下構成との整合）。
  - UIフレームワーク（必要なら）とチャートライブラリ（EChartsなど）依存追加。
  - ディレクトリ初期構成（例）:
    - `app/layout.tsx` … 共通レイアウト・ヘッダナビ
    - `app/page.tsx` … ログイン or ダッシュボード一覧へのリダイレクト

    - `app/(auth)/login/page.tsx` … ログインページ

    - `app/dashboard/page.tsx` … ダッシュボード一覧
    - `app/dashboard/[id]/page.tsx` … ダッシュボード詳細

    - `app/queries/page.tsx` … クエリ一覧/簡易エディタ
    - `app/queries/[id]/page.tsx` … クエリ編集

    - `app/csv/page.tsx` … CSVアップロード画面

    - `app/api-client/` …（任意）APIクライアント・Hooks群
    - `app/components/` … 共通UIコンポーネント
      - `widgets/` … Widget関連（Container/Header/Content/Renderer）
      - `charts/` … チャートコンポーネント
      - `layout/` … ヘッダ・サイドバー等
    - `app/store/` … フィルタやUI状態管理（Zustand等を使う場合）

### Phase 1: 認証 & ユーザー管理

- DB
  - `users` テーブル作成（要件定義書 §9）。
- Backend
  - `auth` モジュール実装
    - `POST /auth/register`（シンプルなemail/password登録）。
    - `POST /auth/login`（JWT発行）。
  - JWTガード/デコレータを共通化（`@UseGuards(AuthGuard)`など）。
- Frontend
  - `app/(auth)/login/page.tsx`
    - メール/パスワード入力フォーム
    - `POST /auth/login` を叩いてJWT取得
    - 成功時: トークンを保存（cookie推奨）し、`/dashboard`へ遷移
  - APIクライアント層
    - `lib/apiClient.ts` 等に`fetch`ラッパを定義
      - リクエストヘッダに自動でJWTを付与
      - エラー形式 `{ error: { code, message } }` を統一的に扱う
  - 認証ガード
    - App Routerのmiddlewareや`useEffect`で未ログイン時は`/login`へリダイレクト

### Phase 2: クエリ管理 & 安全なSQL実行

- DB
  - `data_sources`, `queries`, `query_executions` テーブル作成。
- Backend
  - `data-sources` モジュール
    - `POST /data-sources`, `GET /data-sources`, `DELETE /data-sources/:id`。
    - 暗号化保存ロジック（パスワードなど）実装（簡易でもOK）。
    - `POST /data-sources/test` で接続確認IF実装。
  - `queries` モジュール
    - `POST/GET/PUT/DELETE /queries` のCRUD実装。
    - `parameters(jsonb)` のスキーマ（`{{from}}`, `{{to}}` 等）を文字列で持つ方針の確認。
  - `execute` モジュール
    - `POST /execute` { queryId, params } の実装。
    - 安全設計（基本設計書 §7）
      - `SELECT`限定チェック
      - 危険キーワード遮断
      - `LIMIT`強制
      - `statement_timeout` + アプリ側タイムアウト
      - プリペアドステートメントでのパラメータバインド
      - 実行結果を `query_executions` に保存
- Frontend
  - APIクライアント層
    - `lib/apiClient.ts` に `get/ post/ put/ del` を用意
    - 型定義ファイル `types/api.ts` 等で `Query`, `DataSource`, `ExecuteResponse` などを定義
  - クエリエディタ
    - `app/queries/page.tsx`
      - クエリ一覧テーブル（name / dataSource / 最終更新）
      - 「新規作成」ボタンで`/queries/new`へ
    - `app/queries/[id]/page.tsx`
      - フォーム項目: name, dataSource, sql, parameters(json文字列)
      - 「保存」「テスト実行」ボタン
      - テスト実行は `POST /execute` を叩き、画面下部にテーブル表示
  - 単体Widget試験ページ
    - `app/debug/widget/page.tsx` 等、開発用ページを任意で用意
      - 任意の `queryId` を指定して `/execute` を叩き、結果をテーブル/チャートで表示

### Phase 3: ダッシュボード & ウィジェット & チャート

- DB
  - `dashboards`, `widgets` テーブル作成（位置情報含む）。
- Backend
  - `dashboards` モジュール（CRUD: `POST/GET/DELETE`）。
  - `widgets` モジュール（CRUD: `POST/PUT/DELETE`）。
- Frontend
  - 画面
    - ダッシュボード一覧
      - `app/dashboard/page.tsx`
      - 一覧テーブル + 「新規ダッシュボード作成」ボタン
      - 行クリックで `/dashboard/[id]` へ遷移
    - ダッシュボード詳細
      - `app/dashboard/[id]/page.tsx`
      - 上部: タイトル + 共通フィルタ（from/to）
      - 中央: `react-grid-layout` でWidgetを並べる
      - 右上: 「Widget追加」ボタン（モーダル or ドロワー）
  - コンポーネント
    - `app/components/widgets/WidgetContainer.tsx`
    - `app/components/widgets/WidgetHeader.tsx`
    - `app/components/widgets/WidgetContent.tsx`
    - `app/components/widgets/WidgetRenderer.tsx`
      - `type === 'table' | 'line' | 'bar'` で描画切り替え
    - チャート
      - `app/components/charts/Table.tsx`
      - `app/components/charts/LineChart.tsx`
      - `app/components/charts/BarChart.tsx`
  - フィルタ
    - `app/store/dashboardFilterStore.ts`（Zustandなど）
      - `from`, `to`, `setFrom`, `setTo` など
    - ダッシュボード詳細でストアをProviderとしてラップ
    - WidgetContentではストアの値を `POST /execute` の `params` に渡し、TanStack Queryのキーにも含める

### Phase 4: CSVアップロード「1機能」

- DB
  - CSV専用スキーマ（例: `csv_schema`）を作成。
- Backend
  - `csv` モジュール
    - `POST /csv/upload` (multipart)。
    - CSVの一部サンプルから型推定し、`csv_schema.csv_xxx` テーブルを作成。
    - COPY等でデータ投入。
    - 対象テーブルに対するサンプルSQLを `queries` に登録。
    - 必要であればダッシュボード/ウィジェット自動作成まで行い、`queryId`/`widgetId` をレスポンスに含める。
- Frontend
  - CSVアップロード画面
    - `app/csv/page.tsx`
      - ファイル選択コンポーネント
      - 先頭数行のプレビュー（テーブル）
      - 「アップロード」ボタンで `POST /csv/upload` 実行
      - 実行中はローディングスピナー表示
      - 成功レスポンスの `dashboardId` / `widgetId` を受け取り、`/dashboard/[dashboardId]` へ `router.push`
      - 遷移後、対象Widgetが画面内に見えるよう、スクロール or ハイライト（余裕があれば）

### Phase 5: デモ・運用準備

- デモ用シードデータ
  - ユーザー1件、サンプルデータソース、サンプルクエリ、サンプルダッシュボード/ウィジェットのSeedスクリプト作成。
- エラー/ログ
  - 共通エラーハンドラ実装（`{ error: { code, message } }` 統一）。
  - 実行エラー/タイムアウト/行数制限超過などのログ出力確認。
- デプロイ準備
  - `.env.example` 整備。
  - Docker Composeでのローカル起動手順整理。
  - 本番相当（Vercel + Fly.io or Railway + Managed PostgreSQL）の構成メモをREADMEに反映。

---

## 4. 実装順序とマイルストーン

- M1: Backend/DBの基盤 + 認証 + クエリCRUD 完了
  - 手動でSQLを叩き、`/execute` APIが安全に動くことを確認。
- M2: 単一Widgetページで「SQL → 表/グラフ」表示ができる
  - フロントとBackendが1クエリ経路で疎通。
- M3: Dashboard + Widget CRUD & 配置が動く
  - 複数Widgetを並べた画面が動作。
- M4: CSVアップロードから自動テーブル作成→サンプルSQL→Widget作成が1ストロークで動く
  - 要件の「1機能」達成。
- M5: デモ環境（第三者が5分以内に触れる）が整う
  - README/デモデータ/初期Dashboardが揃う。

---

## 5. テスト戦略（最低限）

- Backend
  - 単体テスト: `execute` モジュールの安全チェック（SELECT限定、危険キーワード、LIMIT挿入）。
  - 統合テスト: `/execute` エンドポイントに対する代表パターン（正常系/タイムアウト/行数制限/不正SQL）。
- Frontend
  - 重要コンポーネント（Widget, Charts）のスモークテスト。
  - 「CSVアップロード〜Dashboard表示」までのE2Eは手動テストでカバー。

---

## 6. リスクと対応

- 複雑な型推定ロジック → MVPでは型推定ルールを単純化（数値/文字列/日付の3種程度）。
- DB性能問題 → LIMIT/timeout/logで検知し、重いクエリは明示的に制約。
- UI/UXの作り込み過多 → コンポーネントやスタイルの凝り過ぎは避け、「見られるレベル」を目標にする。

---

## 7. 今後の拡張を見据えた実装上の注意

- 全テーブルに `tenant_id` を追加しやすいよう、Repository層・API層で `tenant` コンテキストを1か所にまとめる設計にしておく（MVPでは固定値や単一テナント前提）。
- APIレスポンス形式 `{ data, meta } / { error }` を全エンドポイントで揃え、将来のクライアント拡張に備える。
- ビジネスロジックは可能な限りサービス層に寄せ、ControllerはIF変換に専念させる（テスト容易性の確保）。

---

## 8. 画面別ミニ設計（Next.js）

### 8.1 共通レイアウト

- ファイル: `app/layout.tsx`
- 役割:
  - 共通ヘッダ（プロジェクト名、ナビゲーションリンク）
  - グローバルスタイル適用（globals.css）
  - 認証済み状態のチェック（必要なら）

### 8.2 ログイン画面

- ルート: `/login`（`app/(auth)/login/page.tsx`）
- 目的: JWT取得と初回ログイン導線。
- 主なUI要素:
  - メールアドレス入力
  - パスワード入力
  - 「ログイン」ボタン
  - エラーメッセージ表示エリア
- 振る舞い（ざっくり擬似コード）:
  - onSubmitで `POST /auth/login` を呼び出し
  - 成功: `token` を cookie 保存 → `router.push('/dashboard')`
  - 失敗: エラーコードに応じてメッセージ表示

### 8.3 ダッシュボード一覧画面

- ルート: `/dashboard`（`app/dashboard/page.tsx`）
- 目的: 既存ダッシュボードの一覧と新規作成。
- 主なUI要素:
  - ダッシュボード一覧テーブル（name, 作成日 など）
  - 「新規ダッシュボード作成」ボタン
- 振る舞い:
  - マウント時に `GET /dashboards` をTanStack Queryで取得
  - 行クリックで `/dashboard/[id]` へ遷移
  - 「新規作成」押下で `POST /dashboards` → 作成後 `/dashboard/[id]` に飛ばす

### 8.4 ダッシュボード詳細画面

- ルート: `/dashboard/[id]`（`app/dashboard/[id]/page.tsx`）
- 目的: Widgetの配置・編集・表示、共通フィルタの適用。
- 主なUI要素:
  - 画面上部ヘッダ
    - ダッシュボード名
    - 共通フィルタ（from/to）
    - 「全Widget再実行」ボタン
  - メインエリア
    - `react-grid-layout` によるWidget配置エリア
  - 右上アクション
    - 「Widget追加」ボタン（モーダル起動）
- 振る舞い:
  - `GET /dashboards/:id` でメタ情報取得
  - `GET /widgets?dashboardId=:id` でWidget一覧取得
  - 共通フィルタ変更時:
    - dashboardFilterStoreの `from/to` を更新
    - TanStack Queryのキーに `from/to` を含めているため、Widget単位で再フェッチ
  - Widget追加モーダル:
    - 入力項目: query選択, type(table/line/bar), config(json), 初期位置
    - 保存時 `POST /widgets` → クローズ後に一覧再フェッチ

### 8.5 クエリ一覧・編集画面

- 一覧
  - ルート: `/queries`（`app/queries/page.tsx`）
  - 目的: 既存クエリの把握・編集への導線。
  - UI:
    - クエリ一覧テーブル（name, dataSource, 最終更新）
    - 「新規作成」ボタン
  - 振る舞い:
    - `GET /queries` 取得
    - 行クリックで `/queries/[id]` へ遷移
    - 「新規作成」で空のクエリ作成 or `/queries/new` へ

- 編集
  - ルート: `/queries/[id]`（`app/queries/[id]/page.tsx`）
  - 目的: SQLおよびパラメータの編集・テスト実行。
  - UI:
    - フォーム: name, dataSourceセレクト, SQLテキストエリア, parameters(json文字列)
    - ボタン: 「保存」「テスト実行」
    - テスト結果表示テーブル
  - 振る舞い:
    - 初期表示で `GET /queries/:id`
    - 「保存」→ `PUT /queries/:id`
    - 「テスト実行」→ `POST /execute` { queryId, params } → 下部にテーブル表示

### 8.6 CSVアップロード画面

- ルート: `/csv`（`app/csv/page.tsx`）
- 目的: CSVからテーブル作成〜サンプルSQL/Widget自動生成までのワンストローク体験。
- UI:
  - ファイル選択フィールド
  - プレビュー領域（先頭数行をテーブル表示）
  - 「アップロード」ボタン
  - 実行中インジケータ
- 振る舞い:
  - ファイル選択時:
    - フロント側で一時的に先頭数行を読み込み、テーブル表示
  - 「アップロード」押下:
    - `POST /csv/upload` にmultipartで送信
    - 成功レスポンスから `dashboardId`, `widgetId` を取得
    - `router.push('/dashboard/' + dashboardId)` で遷移
    - 余力があれば `widgetId` にスクロール or ハイライト

### 8.7 単体Widgetデバッグ画面（任意）

- ルート: `/debug/widget`（`app/debug/widget/page.tsx`）
- 目的: Dashboardに乗せる前にWidget表示まわりを検証するための開発用ページ。
- UI:
  - 入力: queryId, type, config(json)
  - 「実行」ボタン
  - 下部にWidgetRendererを1つだけ表示
- 振る舞い:
  - `POST /execute` でデータ取得
  - 取得結果を`WidgetRenderer`に渡して表示

以上の計画に従い、まずは Phase 0〜2 を集中的に進めて「安全なSQL実行 + 単体Widget表示」までを早期に立ち上げ、その後Dashboard/CSV/デモ整備へ拡張していく。